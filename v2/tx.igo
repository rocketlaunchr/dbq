// Copyright 2019-20 PJ Engineering and Business Solutions Pty. Ltd. All rights reserved.

package dbq

import (
	"context"
	"database/sql"
	"fmt"

	rlSql "github.com/rocketlaunchr/mysql-go"
	"gopkg.in/cenkalti/backoff.v4"
	// "github.com/cenkalti/backoff/v4"
)

type txer interface {
	Commit() error
	Rollback() error
}

// QFn is shorthand for Q. It will automatically use the appropriate transaction.
type QFn func(ctx context.Context, query string, options *Options, args ...interface{}) (interface{}, error)

// EFn is shorthand for E. It will automatically use the appropriate transaction.
type EFn func(ctx context.Context, query string, options *Options, args ...interface{}) (sql.Result, error)

// TxCommit will commit the transaction.
type TxCommit func() error

// Tx is used to perform an arbitrary operation and not have to worry about rolling back a transaction.
// The transaction is automatically rolled back unless committed by calling txCommit.
// tx is only exposed for performance purposes. Do not use it to commit or rollback.
//
// NOTE: Until this note is removed, this function is not necessarily backward compatible.
//
// Example:
//
//  ctx := context.Background()
//  pool, _ := sql.Open("mysql", "user:password@tcp(localhost:3306)/db")
//
//  dbq.Tx(ctx, pool, func(tx interface{}, Q dbq.QFn, E dbq.EFn, txCommit dbq.TxCommit) {
//
//  	stmt := dbq.INSERT("table", []string{"name", "age", "created_at"}, 1)
//  	res, err := E(ctx, stmt, nil, "test name", 34, time.Now())
//  	if err != nil {
//  		return // Automatic rollback
//  	}
//  	txCommit()
//  })
//
func Tx(ctx context.Context, db interface{}, fn func(tx interface{}, Q QFn, E EFn, txCommit TxCommit), retryPolicy ...backoff.BackOff) error {

	var (
		alreadyTx bool
		tx        interface{}
		err       error
	)

	// Check if db is valid
	switch db := db.(type) {
	case BeginTxer:
		tx, err = db.BeginTx(ctx, nil)
		if err != nil {
			return err
		}
	case beginTxer2:
		tx, err = db.BeginTx(ctx, nil)
		if err != nil {
			return err
		}
	case *sql.Tx, *rlSql.Tx:
		tx = db
		alreadyTx = true
	default:
		panic(fmt.Sprintf("interface conversion: %T is not dbq.BeginTxer: missing method: BeginTx", db))
	}

	defer func() {
		if r := recover(); r != nil {
			tx.(txer).Rollback()
			panic(r)
		}
	}()

	qFn := func(ctx context.Context, query string, options *Options, args ...interface{}) (interface{}, error) {
		res, err := Q(ctx, tx, query, options, args...)
		if err == sql.ErrTxDone && !alreadyTx {
			return Q(ctx, db, query, options, args...)
		}
		return res, err
	}

	eFn := func(ctx context.Context, query string, options *Options, args ...interface{}) (sql.Result, error) {
		return E(ctx, tx.(ExecContexter), query, options, args...)
	}

	completed := false
	txCommit := func() error {
		err := tx.(txer).Commit()
		if err == nil || err == sql.ErrTxDone {
			completed = true
			return nil
		}
		return err
	}

	operation := func() error {
		fn(tx, qFn, eFn, txCommit)
		if completed {
			return nil
		}
		err = tx.(txer).Rollback()
		if err == sql.ErrTxDone {
			return nil
		}
		return err
	}

	if !(len(retryPolicy) > 0 && retryPolicy[0] != nil) {
		// No retry
		return operation()
	}

	return backoff.Retry(operation, backoff.WithContext(retryPolicy[0], ctx))
}
